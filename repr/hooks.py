"""
Git hook management for repr.

Handles installation and removal of post-commit hooks that queue commits
for story generation. Implements local commit queue with file locking.
"""

import json
import os
import stat
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import Any

from git import Repo, InvalidGitRepositoryError

# Cross-platform file locking
if sys.platform == "win32":
    import msvcrt
    _USE_FCNTL = False
else:
    import fcntl
    _USE_FCNTL = True


# Hook script that queues commits locally (never triggers cloud)
HOOK_SCRIPT = '''#!/bin/sh
# repr post-commit hook - queue commits for story generation
# Auto-generated by repr CLI
# This hook only queues commits locally; no network calls are made.

# Get commit info
COMMIT_SHA=$(git rev-parse HEAD)
COMMIT_MSG=$(git log -1 --format="%s" HEAD)
REPO_ROOT=$(git rev-parse --show-toplevel)

# Queue the commit
repr hooks queue "$COMMIT_SHA" --repo "$REPO_ROOT" 2>/dev/null || true
'''


def is_git_repo(path: Path) -> bool:
    """Check if path is a git repository.
    
    Args:
        path: Path to check
    
    Returns:
        True if path is a git repo
    """
    try:
        Repo(path)
        return True
    except InvalidGitRepositoryError:
        return False


def get_hook_path(repo_path: Path) -> Path:
    """Get path to post-commit hook file.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Path to post-commit hook
    """
    return repo_path / ".git" / "hooks" / "post-commit"


def get_repr_dir(repo_path: Path) -> Path:
    """Get path to .git/repr/ directory for a repo.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Path to .git/repr/ directory
    """
    return repo_path / ".git" / "repr"


def get_queue_path(repo_path: Path) -> Path:
    """Get path to queue.json file for a repo.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Path to queue.json file
    """
    return get_repr_dir(repo_path) / "queue.json"


def get_repo_id_path(repo_path: Path) -> Path:
    """Get path to repo_id file.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Path to repo_id file
    """
    return get_repr_dir(repo_path) / "repo_id"


def is_hook_installed(repo_path: Path) -> bool:
    """Check if repr hook is installed in repository.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        True if hook is installed and contains repr queue command
    """
    hook_path = get_hook_path(repo_path)
    
    if not hook_path.exists():
        return False
    
    try:
        content = hook_path.read_text()
        # Check if it's our hook
        return "repr hooks queue" in content and "# Auto-generated by repr CLI" in content
    except Exception:
        return False


def install_hook(repo_path: Path) -> dict[str, Any]:
    """Install post-commit hook in repository.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Dict with 'success', 'message', 'already_installed' keys
    """
    if not is_git_repo(repo_path):
        return {
            "success": False,
            "message": f"Not a git repository: {repo_path}",
            "already_installed": False,
        }
    
    # Check if .git is writable
    git_dir = repo_path / ".git"
    if not os.access(git_dir, os.W_OK):
        return {
            "success": False,
            "message": f"Cannot install hook: .git directory is read-only",
            "already_installed": False,
        }
    
    hook_path = get_hook_path(repo_path)
    
    # Ensure hooks directory exists
    hook_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Ensure repr directory exists
    repr_dir = get_repr_dir(repo_path)
    repr_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate repo ID if not exists
    repo_id_path = get_repo_id_path(repo_path)
    if not repo_id_path.exists():
        import uuid
        repo_id_path.write_text(str(uuid.uuid4()))
    
    # Check if hook already exists
    if hook_path.exists():
        existing_content = hook_path.read_text()
        
        # If it's our hook, nothing to do
        if is_hook_installed(repo_path):
            return {
                "success": True,
                "message": "Hook already installed",
                "already_installed": True,
            }
        
        # If there's another hook, append ours
        if existing_content.strip():
            # Backup existing hook
            backup_path = hook_path.with_suffix(".pre-repr")
            backup_path.write_text(existing_content)
            
            # Append our hook
            new_content = existing_content.rstrip() + "\n\n" + HOOK_SCRIPT
            hook_path.write_text(new_content)
            
            # Make executable
            hook_path.chmod(hook_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
            
            return {
                "success": True,
                "message": f"Hook appended (existing hook backed up to {backup_path.name})",
                "already_installed": False,
            }
    
    # Create new hook
    hook_path.write_text(HOOK_SCRIPT)
    
    # Make executable
    hook_path.chmod(hook_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    
    return {
        "success": True,
        "message": "Hook installed successfully",
        "already_installed": False,
    }


def remove_hook(repo_path: Path) -> dict[str, Any]:
    """Remove repr post-commit hook from repository.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Dict with 'success', 'message' keys
    """
    if not is_git_repo(repo_path):
        return {
            "success": False,
            "message": f"Not a git repository: {repo_path}",
        }
    
    hook_path = get_hook_path(repo_path)
    
    if not hook_path.exists():
        return {
            "success": True,
            "message": "No hook to remove",
        }
    
    try:
        content = hook_path.read_text()
        
        # If it's entirely our hook, delete the file
        if content.strip() == HOOK_SCRIPT.strip():
            hook_path.unlink()
            return {
                "success": True,
                "message": "Hook removed successfully",
            }
        
        # If our hook is appended, remove just our part
        if "# Auto-generated by repr CLI" in content:
            # Find and remove our section
            lines = content.split("\n")
            new_lines = []
            skip = False
            
            for i, line in enumerate(lines):
                if "# repr post-commit hook" in line and "repr CLI" in content[content.index(line):]:
                    skip = True
                    continue
                if skip:
                    # Skip until we hit a line that's clearly not part of our hook
                    if line.strip() and not line.startswith("#") and "repr" not in line and "COMMIT" not in line and "REPO" not in line:
                        skip = False
                        new_lines.append(line)
                    continue
                new_lines.append(line)
            
            new_content = "\n".join(new_lines).strip()
            
            if new_content:
                hook_path.write_text(new_content + "\n")
                return {
                    "success": True,
                    "message": "repr hook removed (other hooks preserved)",
                }
            else:
                hook_path.unlink()
                return {
                    "success": True,
                    "message": "Hook file removed (was empty after removing repr hook)",
                }
        
        return {
            "success": False,
            "message": "Hook file exists but doesn't contain repr hook",
        }
        
    except Exception as e:
        return {
            "success": False,
            "message": f"Error removing hook: {str(e)}",
        }


def get_hook_status(repo_path: Path) -> dict[str, Any]:
    """Get hook installation status for a repository.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Dict with 'installed', 'path', 'executable', 'queue_count' keys
    """
    if not is_git_repo(repo_path):
        return {
            "installed": False,
            "path": None,
            "executable": False,
            "queue_count": 0,
            "error": "Not a git repository",
        }
    
    hook_path = get_hook_path(repo_path)
    installed = is_hook_installed(repo_path)
    
    executable = False
    if hook_path.exists():
        executable = os.access(hook_path, os.X_OK)
    
    # Get queue count
    queue = load_queue(repo_path)
    
    return {
        "installed": installed,
        "path": str(hook_path) if hook_path.exists() else None,
        "executable": executable,
        "queue_count": len(queue),
    }


# ============================================================================
# Queue Management
# ============================================================================

LOCK_TIMEOUT = 2  # seconds to wait for lock


class QueueLockError(Exception):
    """Failed to acquire queue lock."""
    pass


def _acquire_lock(lock_path: Path, timeout: float = LOCK_TIMEOUT) -> int:
    """Acquire a file lock.
    
    Args:
        lock_path: Path to lock file
        timeout: Seconds to wait
    
    Returns:
        File descriptor
    
    Raises:
        QueueLockError: If lock cannot be acquired
    """
    lock_path.parent.mkdir(parents=True, exist_ok=True)
    fd = os.open(str(lock_path), os.O_CREAT | os.O_RDWR)
    
    start = time.time()
    while time.time() - start < timeout:
        try:
            if _USE_FCNTL:
                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            else:
                # Windows: lock the first byte of the file
                msvcrt.locking(fd, msvcrt.LK_NBLCK, 1)
            return fd
        except (IOError, OSError):
            time.sleep(0.1)
    
    os.close(fd)
    raise QueueLockError(f"Could not acquire queue lock after {timeout}s")


def _release_lock(fd: int) -> None:
    """Release a file lock."""
    try:
        if _USE_FCNTL:
            fcntl.flock(fd, fcntl.LOCK_UN)
        else:
            # Windows: unlock the first byte
            try:
                msvcrt.locking(fd, msvcrt.LK_UNLCK, 1)
            except (IOError, OSError):
                pass  # May fail if not locked, ignore
        os.close(fd)
    except Exception:
        pass


def load_queue(repo_path: Path) -> list[dict[str, Any]]:
    """Load commit queue for a repository.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        List of queued commit entries
    """
    queue_path = get_queue_path(repo_path)
    
    if not queue_path.exists():
        return []
    
    try:
        return json.loads(queue_path.read_text())
    except (json.JSONDecodeError, IOError):
        return []


def save_queue(repo_path: Path, queue: list[dict[str, Any]]) -> None:
    """Save commit queue for a repository.
    
    Args:
        repo_path: Path to repository root
        queue: List of queued commit entries
    """
    queue_path = get_queue_path(repo_path)
    queue_path.parent.mkdir(parents=True, exist_ok=True)
    queue_path.write_text(json.dumps(queue, indent=2))


def queue_commit(repo_path: Path, commit_sha: str, message: str | None = None) -> bool:
    """Add a commit to the queue.
    
    Uses file locking to handle concurrent commits safely.
    
    Args:
        repo_path: Path to repository root
        commit_sha: Full commit SHA
        message: Optional commit message
    
    Returns:
        True if queued successfully
    """
    queue_path = get_queue_path(repo_path)
    lock_path = queue_path.with_suffix(".lock")
    
    try:
        fd = _acquire_lock(lock_path)
        try:
            queue = load_queue(repo_path)
            
            # Check if already queued
            if any(c["sha"] == commit_sha for c in queue):
                return True
            
            # Add to queue
            queue.append({
                "sha": commit_sha,
                "message": message,
                "queued_at": datetime.now().isoformat(),
            })
            
            save_queue(repo_path, queue)
            return True
            
        finally:
            _release_lock(fd)
            
    except QueueLockError:
        # Could not get lock, skip queuing
        return False


def dequeue_commits(repo_path: Path, commit_shas: list[str]) -> int:
    """Remove commits from the queue.
    
    Args:
        repo_path: Path to repository root
        commit_shas: List of commit SHAs to remove
    
    Returns:
        Number of commits removed
    """
    queue_path = get_queue_path(repo_path)
    lock_path = queue_path.with_suffix(".lock")
    
    try:
        fd = _acquire_lock(lock_path)
        try:
            queue = load_queue(repo_path)
            original_len = len(queue)
            
            # Remove specified commits
            queue = [c for c in queue if c["sha"] not in commit_shas]
            
            save_queue(repo_path, queue)
            return original_len - len(queue)
            
        finally:
            _release_lock(fd)
            
    except QueueLockError:
        return 0


def clear_queue(repo_path: Path) -> int:
    """Clear all commits from the queue.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Number of commits cleared
    """
    queue_path = get_queue_path(repo_path)
    lock_path = queue_path.with_suffix(".lock")
    
    try:
        fd = _acquire_lock(lock_path)
        try:
            queue = load_queue(repo_path)
            count = len(queue)
            save_queue(repo_path, [])
            return count
        finally:
            _release_lock(fd)
    except QueueLockError:
        return 0


def cleanup_orphaned_commits(repo_path: Path) -> list[str]:
    """Remove commits from queue that no longer exist in repo history.
    
    This handles rebases, amends, and other history rewrites.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        List of removed commit SHAs
    """
    try:
        repo = Repo(repo_path)
    except InvalidGitRepositoryError:
        return []
    
    queue = load_queue(repo_path)
    if not queue:
        return []
    
    orphaned = []
    valid = []
    
    for entry in queue:
        sha = entry["sha"]
        try:
            # Check if commit exists
            repo.commit(sha)
            valid.append(entry)
        except Exception:
            orphaned.append(sha)
    
    if orphaned:
        # Save cleaned queue
        queue_path = get_queue_path(repo_path)
        lock_path = queue_path.with_suffix(".lock")
        
        try:
            fd = _acquire_lock(lock_path)
            try:
                save_queue(repo_path, valid)
            finally:
                _release_lock(fd)
        except QueueLockError:
            pass
    
    return orphaned


def get_queue_stats(repo_path: Path) -> dict[str, Any]:
    """Get queue statistics for a repository.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Dict with queue stats
    """
    queue = load_queue(repo_path)
    
    if not queue:
        return {
            "count": 0,
            "oldest": None,
            "newest": None,
        }
    
    # Get timestamps
    timestamps = [c.get("queued_at") for c in queue if c.get("queued_at")]
    
    return {
        "count": len(queue),
        "oldest": min(timestamps) if timestamps else None,
        "newest": max(timestamps) if timestamps else None,
        "commits": [c["sha"][:7] for c in queue],
    }


def get_repo_id(repo_path: Path) -> str | None:
    """Get the stable repo ID.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Repo UUID or None if not set
    """
    repo_id_path = get_repo_id_path(repo_path)
    if repo_id_path.exists():
        return repo_id_path.read_text().strip()
    return None


def ensure_repo_id(repo_path: Path) -> str:
    """Ensure repo has a stable ID, creating one if needed.
    
    Args:
        repo_path: Path to repository root
    
    Returns:
        Repo UUID
    """
    import uuid
    
    repo_id_path = get_repo_id_path(repo_path)
    repo_id_path.parent.mkdir(parents=True, exist_ok=True)
    
    if repo_id_path.exists():
        return repo_id_path.read_text().strip()
    
    new_id = str(uuid.uuid4())
    repo_id_path.write_text(new_id)
    return new_id
